/* Target-dependent code for GNU/Linux E2K64.

   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "osabi.h"
#include "regcache.h"
#include "regset.h"
#include "solib-svr4.h"
#include "symtab.h"
#include "xml-syscall.h"
#include "gdbarch.h"

#include "e2k-tdep.h"
#include "linux-tdep.h"
#include "e2k-linux-tdep.h"

LONGEST
e2k_linux_get_syscall_number (struct gdbarch *gdbarch,
                              thread_info *thread)
{
  struct regcache *regcache = get_thread_regcache (thread);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  /* The content of a register.  */
  gdb_byte buf[8];
  /* The result.  */
  LONGEST ret;

  /* Getting the system call number from the register.
     When dealing with the e2k architecture, this information
     is stored at the %b[0] register.  */
  regcache->cooked_read (VB0_REGNUM, buf);

  ret = extract_signed_integer (buf, 8, byte_order);

  return ret;
}

/* Helper functions for dealing with register sets.  */

void
e2k_supply_gregset (struct regcache *regcache,
                    int regnum,
		    const e2k_linux_gregset_t gregs,
		    size_t len)
{
  const gdb_byte *regs = (const gdb_byte *) gregs;
  const void *buf;

  if (regnum == -1)
    {
      for (regnum = 0; regnum < NUM_E2K_RAW_REGS; regnum++)
        e2k_supply_gregset (regcache, regnum, gregs, len);

      return;
    }

  /* Raw registers up to `%mlt_15' inclusively along with `%p{,c}sp_base' can
     be accessed via any "user_regs_struct", those lying beyond this range
     require the latest version (see Bug #81304, Comment #4).  */
  if ((gregs[0] == SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT
       || (gregs[0] == SIZE_OF_ELBRUS_V5_USER_REGS_STRUCT
	   && regnum >= E2K_LSR1_REGNUM
	   && regnum <= E2K_GTAG_V5_31_REGNUM)
       /* These registers are provided by old-style corefiles as well.  */
       || regnum <= E2K_MLT_15
       /* `%pcsp_base' should be considered as available even if it's not for
	  the current implementation of GDB to work. In such a case it will be
	  automagically zeroed out (recall that GREGS past len is filled in with
	  zeroes prior to calling this function) which will instruct `e2k_frame
	  _this_id ()' not to rely on it.  */
       || regnum == E2K_PCSP_BASE
       || (len >= SIZE_OF_ELBRUS_V5_USER_REGS_STRUCT
	   /* The following registers can be obtained even when the Kernel
	      doesn't support the new implementation of `PTRACE_GETREGS' either
	      when debugging a live process or when reading a new-style corefile
	      generated by GDB.  */
	   && ((regnum == E2K_PSP_BASE
		/* `%p{,c}sp_base' may turn out to be unavailable despite all
		   my efforts if an ancient Kernel doesn't mark the related
		   memory regions in `/proc/PID/maps' appropriately. Because
		   `%psp_base' unlike`%pcsp_base' doesn't play a special role
		   for GDB (see above), it makes sense to consider it as
		   unavailable rather than equal to zero.  */
		&& gregs[gregset_idx (regnum)] != 0)
	       /* These ones should be always available when debugging a live
		  process or a new-style corefile generated by GDB even if the
		  Kernel provides no support: `rrd %{idr,core_mode}, . . .' is
		  sure to work under all circumstances.  */
	       || regnum == E2K_IDR_REGNUM
	       || regnum == E2K_CORE_MODE_REGNUM))
       /* Oh, these awful `%pusd_{lo,hi}' registers. They aren't transferred to
          GDBSERVER since that would be a duplication and therefore they lie
          past those elbrus-v5 specific registers which are. But they should be
          supplied to REGCACHE if we want the user to be able to read them.  */
       || regnum == E2K_PUSD_LO_REGNUM
       || regnum == E2K_PUSD_HI_REGNUM)
      && byte_offset (regnum) != -1)
    buf = regs + byte_offset (regnum);
  else
    buf = NULL;

  regcache->raw_supply (regnum, buf);
}

void
e2k_supply_fpregset (const int *reg_offsets,
                    struct regcache *regcache,
                    int regnum, const void *gregs)
{
}

void
e2k_collect_gregset (const int *reg_offsets,
                     const struct regcache *regcache,
                     int regnum,
                     void *gregs,
                     int to_core)
{
  gdb_byte *regs = (gdb_byte *) gregs;

  if (regnum == -1)
    {
      for (regnum = 0; regnum < NUM_E2K_RAW_REGS; regnum++)
        e2k_collect_gregset (reg_offsets, regcache, regnum, gregs, to_core);

      return;
    }

  /* FIXME: is there any reason not to collect the below registers into a buffer
     passed to PTRACE_SETREGS? Anyway, they should be saved into corefile, of
     course.  */
  if (reg_offsets[regnum] != -1
      && (to_core
          || (regnum != E2K_PCSP_LO_REGNUM
              && regnum != E2K_PCSP_HI_REGNUM
              && regnum != E2K_PSP_LO_REGNUM
              && regnum != E2K_PSP_HI_REGNUM
              && regnum != E2K_CR1_LO_REGNUM
              && regnum != E2K_WD_REGNUM))
      )
    regcache->raw_collect (regnum, regs + reg_offsets[regnum]);
}


static void
e2k_linux_supply_core_gregset (const struct regset *regset,
                               struct regcache *regcache,
                               int regnum,
                               const void *regs,
                               size_t len)
{
  e2k_linux_gregset_t gregs;

  /* Currently there are no situations in which this function could be called
     with REGNUM different from -1.  */
  gdb_assert (regnum == -1);

  /* According to the implementation of corelow.c and the use of `REGSET_
     VARIABLE_SIZE' flag below we may very well find ourselves here if a
     corefile contains `.reg' section having any size greater or equal than
     SIZE_OF_ELBRUS_V1_USER_REGS_STRUCT.  */
  if (len != SIZE_OF_ELBRUS_V1_USER_REGS_STRUCT
      && len != SIZE_OF_ELBRUS_V5_USER_REGS_STRUCT
      && len < SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT)
    error (_("Unsupported size of .reg section in corefile"));
  

  /* FIXME: this hack lets me take into account that E2K_PCSP_BASE isn't saved
     in a regular way within a core file (as well as it can't be obtained via
     ptrace ()).  */

  memcpy (gregs, regs, (len <= SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT
			? len : SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT));
  if (gregs[0] != (unsigned long long) len
      /* Allow for corefiles generated by GDB under older Kernels.  */
      && ! (len == SIZE_OF_ELBRUS_V5_USER_REGS_STRUCT
	    && gregs[0] == SIZE_OF_ELBRUS_V1_USER_REGS_STRUCT)
      && ! (len == SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT
	    && (gregs[0] == SIZE_OF_ELBRUS_V1_USER_REGS_STRUCT
		|| gregs[0] == SIZE_OF_ELBRUS_V5_USER_REGS_STRUCT)))
    error (_(".reg section in corefile is damaged"));

  if (len > SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT)
      gregs[0] = len = SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT;

  /* Stupidly zero out the part of REGS[] corresponding to registers not
     provided via the corefile under consideration.  */
  if (len  == SIZE_OF_ELBRUS_V1_USER_REGS_STRUCT)
    memset (&gregs[gregset_idx (E2K_IDR_REGNUM)], 0,
	    byte_offset (E2K_PCSP_OFFSET) - byte_offset (E2K_IDR_REGNUM));
  else if (len == SIZE_OF_ELBRUS_V5_USER_REGS_STRUCT)
    memset (&gregs[gregset_idx (E2K_DIMTP_LO_REGNUM)], 0,
	    byte_offset (E2K_PCSP_OFFSET) - byte_offset (E2K_DIMTP_LO_REGNUM));

  /* Zero out `%_pcsp_offset'. It's unlikely to play any role here at all.  */
  gregs[gregset_idx (E2K_PCSP_OFFSET)] = 0;
  
  e2k_supply_gregset (regcache, regnum, gregs, len);
}

static void
e2k_linux_collect_core_gregset (const struct regset *regset,
                                const struct regcache *regcache,
                                int regnum, void *gregs, size_t len)
{
  /* FIXME: how could I arrange to use `e2k_linux_gregset_t' from `gdb/nat
     /e2k-linux.h' here as well?  */
  e2k_linux_gregset_t regs;

  /* Currently there are no situations in which this function could be called
     with REGNUM different from -1.  */
  gdb_assert (regnum == -1);

  /* We can be invoked to fill in ".reg" section for the latest flavour of core
     files only (see `e2k_linux_iterate_over_regset_sections ()'). There is
     just no point in producing older ones.  */
  gdb_assert (len == SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT);

  e2k_collect_gregset (e2k_linux_ptrace_offsets, regcache, regnum, regs, 1);
  if (regs[0] != SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT)
    {
      /* This may happen if the Kernel in use supports OLDER variants of `user_
         regs_struct' only. Nevertheless, I create the latest-style corefile
	 since it lets me provide `%p{c,}sp_base,%idr,%core_mode' registers
	 to the user. To let the reader know that other `elbrus-v{5,6}'-specific
	 registers (i.e. `%ilcr1' and `%lsr1') are unavailable in this corefile,
	 I intentionally leave `regs[0]' equal to the original `user_regs_
	 struct's size.  */
      gdb_assert (regs[0] == SIZE_OF_ELBRUS_V1_USER_REGS_STRUCT
		  || regs[0] == SIZE_OF_ELBRUS_V5_USER_REGS_STRUCT);
    }

  memcpy (gregs, regs, len);
}


const struct regset e2k_linux_gregset =
  {
    NULL,
    e2k_linux_supply_core_gregset,
    e2k_linux_collect_core_gregset,
    REGSET_VARIABLE_SIZE
  };


/* Iterate over core file register note sections.  */

void
e2k_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,
                                        iterate_over_regset_sections_cb *cb,
                                        void *cb_data,
                                        const struct regcache *regcache)
{
  /* If we are in write (gcore) mode, which is signalized by REGCACHE set to a
     value different from NULL, specify the size of the latest `user_regs_
     struct': we are not going to produce old-style corefiles. Otherwise use
     size of the most ancient `user_regs_struct' to prevent `get_core_register_
     section ()' from rejecting `.reg' section in an old-style corefile as being
     of an insufficiently large size. Note that the use of REGSET_VARIABLE_SIZE
     flag in the definition of `e2k_linux_gregset' above should make it possible
     to accept larger `.reg' sections in new-style corefiles though . . .  */
  int size = (regcache != NULL
	      ? SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT
	      : SIZE_OF_ELBRUS_V1_USER_REGS_STRUCT);
  cb (".reg", size, size, &e2k_linux_gregset, NULL, cb_data);
}

static const struct target_desc *
e2k_linux_core_read_description (struct gdbarch *gdbarch,
                                 struct target_ops *target,
                                 bfd *abfd)
{
  asection *reg = bfd_get_section_by_name (abfd, ".reg");

  if (reg)
    {
      unsigned long long idr;
      unsigned long long mdl;
      char contents[8];
      size_t size = bfd_section_size (reg);

      if (size != SIZE_OF_ELBRUS_V5_USER_REGS_STRUCT
	  && size != SIZE_OF_ELBRUS_V6_USER_REGS_STRUCT)
        return tdesc_e2k_linux;

      if (! bfd_get_section_contents (abfd, reg, contents,
                                      byte_offset (E2K_IDR_REGNUM), 8))
	    {
	      warning (_("Couldn't read `%%idr' bytes from "
			 "`.reg' section in core file."));
	      return tdesc_e2k_linux;
	    }

	  idr = bfd_get_64 (abfd, contents);
          mdl = idr & 0xff;
          if (mdl == 2 || mdl == 4 || mdl == 6)
            return tdesc_elbrus_v2_linux;
          /* 3 is the only value corresponding to `elbrus-v3', 7 and 8 stand
             for `elbrus-v4' processors. Recall that we don't have `elbrus-v4'-
             specific registers meanwhile.  */
          else if (mdl == 3 || mdl == 7 || mdl == 8)
            return tdesc_elbrus_v3_linux;
          else if (mdl == 9)
            return tdesc_elbrus_v5_linux;
	  /* 10, 11 and 12 are used for elbrus-{12c,16,2c3} respectively. */
	  else if (mdl == 10 || mdl == 11 || mdl == 12)
	    return tdesc_elbrus_v6_linux;
    }

  return tdesc_e2k_linux;
}


static const char *exceptions[] = {
  "exc_illegal_opcode",
  "exc_priv_action",
  "exc_fp_disabled",
  "exc_fp_stack_u",
  "exc_d_interrupt",
  "exc_diag_ct_cond",
  "exc_diag_instr_addr",
  "exc_illegal_instr_addr",
  "exc_instr_debug",
  "exc_window_bounds",
  "exc_user_stack_bounds",
  "exc_proc_stack_bounds",
  "exc_chain_stack_bounds",
  "exc_fp_stack_o",
  "exc_diag_cond",
  "exc_diag_operand",
  "exc_illegal_operand",
  "exc_array_bounds",
  "exc_access_rights",
  "exc_addr_not_aligned",
  "exc_instr_page_miss",
  "exc_instr_page_prot",
  "exc_ainstr_page_miss",
  "exc_ainstr_page_prot",
  "exc_last_wish",
  "exc_base_not_aligned",
  "exc_unknown",
  "exc_unknown",
  "exc_data_debug",
  "exc_data_page",
  "exc_unknown",
  "exc_unknown",

  /* Inhibit info on "exc_interrupt" so as not to confuse a user when an
     inferior is interrupted by means of `Ctrl + C' or `$ kill -SIGzzz pid'.  */
  "",

  "exc_nm_interrupt",
  "exc_div",
  "exc_fp",
  "exc_mem_lock",
  "exc_mem_lock_as",
  "",
  "",
  "",
  "",
  "",
  ""
};


void
e2k_linux_handle_segmentation_fault (struct gdbarch *gdbarch,
                                     struct ui_out *uiout)
{
  int i;
  ULONGEST tir_lo;
  ULONGEST tir_hi;
  struct regcache *regcache = get_current_regcache ();

  /* Have we output any verbose info on current exception(s)?  */
  int exc_printed = 0;

  /* I'm yet to see an exception reported via `TIR{j > 1}'. At the same time
     one may currently obtain invalid values of these registers on buggy kernels
     due to Bug #83608. Therefore, limit yourself to `%TIR{0,1}' for now.  */
  for (i = 0; i < 2 /* 19  */; i++)
    {
      int j;
      ULONGEST exc;
      ULONGEST als;
      char exc_str[1024] = "";
      char als_str[64] = "";
      char *p;
      int exc_met = 0;
      int als_met = 0;

      regcache_cooked_read_unsigned (regcache, E2K_TIR_0_HI + i, &tir_hi);
      exc = tir_hi & 0xfffffffffffULL;

      if (exc == 0)
        continue;

      als = (tir_hi >> 44) & 0x3f;

      regcache_cooked_read_unsigned (regcache, E2K_TIR_0_LO + i, &tir_lo);

      p = exc_str;
      for (j = 0; j < 44; j++)
        {
          if ((exc & (1UL << j)) != 0 && exceptions[j][0] != '\0')
	    {
	      /* See if the terminating '\0' belongs to `exc_str[]' and break
		 if not.  */
	      if (p + (exc_met ? 3 : 0) + strlen (exceptions[j])
		  >= exc_str + sizeof (exc_str))
		break;

              if (exc_met)
                p = stpcpy (p, " | ");
              else
                exc_met = 1;

              p = stpcpy (p, exceptions[j]);
            }
        }

      if (exc_met)
        {
          p = als_str;
          for (j = 0; j < 6; j++)
            {
              if ((als & (1UL << j)) != 0)
                {
                  if (als_met)
                    p = stpcpy (p, " | ALS");
                  else
                    {
                      p = stpcpy (p, "ALS");
                      als_met = 1;
                    }

                  *p++ = '0' + j;
                }
            }

          if (exc_printed == 0)
            {
              uiout->text ("\n\n");
              exc_printed = 1;
            }
          
          uiout->field_fmt ("exc", "%s%s at", exc_str,
                            i > 0 ? " delayed interrupt" : "");
          uiout->field_fmt ("pc", " %s", paddress (gdbarch, tir_lo));
          uiout->field_fmt ("als", " %s", als_str);
          uiout->text ("\n");
        }

      /* I've already seen a precise exception. There's no point in processing
         delayed ones in such a case since according to iset.single precise and
         delayed exceptions are never reported together. More over, on buggy
         kernels (see Bug #83608) delayed entries may very contain junk or
         stale values. I stopped checking for `exc_met' here because we should
         break even if a non-printable exception has been met.  */
      if (i == 0)
	break;
    }

  uiout->text (exc_printed ? "\n" : ".\n");
}




static void
e2k_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  linux_init_abi (info, gdbarch);
  e2k_init_abi (info, gdbarch);

  /* GNU/Linux has SVR4-style shared libraries...  */
  set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);
  set_solib_svr4_fetch_link_map_offsets
    (gdbarch, svr4_lp64_fetch_link_map_offsets);


  /* Functions for 'catch syscall'.  */
  set_xml_syscall_file_name (gdbarch, "syscalls/e2k-linux.xml");
  set_gdbarch_get_syscall_number (gdbarch,
                                  e2k_linux_get_syscall_number);

  /* Enable TLS support.  */
  set_gdbarch_fetch_tls_load_module_address (gdbarch,
                                             svr4_fetch_objfile_link_map);

  set_gdbarch_iterate_over_regset_sections
    (gdbarch, e2k_linux_iterate_over_regset_sections);

  set_gdbarch_core_read_description (gdbarch,
                                     e2k_linux_core_read_description);

  set_gdbarch_handle_segmentation_fault (gdbarch,
                                         e2k_linux_handle_segmentation_fault);

#if 0
  /* Hook in the DWARF CFI frame unwinder.  */
  dwarf2_append_unwinders (gdbarch);
#endif /* 0  */

#if 0
  /* ...which means that we need some special handling when doing
     prologue analysis.  */
  tdep->plt_entry_size = 64;
#endif /* 0 */

}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern void _initialize_e2k_linux_tdep (void);

void
_initialize_e2k_linux_tdep (void)
{
  gdbarch_register_osabi (bfd_arch_e2k,
			  /* The use of generic below ensures that
			     `GDBARCH_INFO.bfd_arch_info' whatever it's set to
			     is believed to be capable of running our code in
			     gdbarch_init_osabi () which makes `e2k_linux_init_
			     abi ()' invoked.
			     FIXME: a special macro should be introduced to
			     obtain the 64-bit ABI machine number.  */
			  4 * bfd_mach_e2k_generic,
			  GDB_OSABI_LINUX, e2k_linux_init_abi);
}
